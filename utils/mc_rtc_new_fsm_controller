#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Copyright 2015-2019 CNRS-UM LIRMM, CNRS-AIST JRL
#

import argparse
import imp
import os

mod = imp.load_source('mc_rtc_new_controller', os.path.dirname(__file__) + '/mc_rtc_new_controller')
new_controller = mod.new_controller

def new_fsm_controller(project_dir, controller_class_name, controller_name):
    if not os.path.isabs(project_dir):
        return new_fsm_controller(os.path.abspath(project_dir), controller_class_name, controller_name)
    if controller_name is None:
        return new_fsm_controller(project_dir, controller_class_name, controller_class_name)
    repo = new_controller(project_dir, controller_class_name, controller_name, base_class = 'mc_control::fsm::Controller', base_use_conf = True, extra_includes = ['mc_control/fsm/Controller.h'], extra_libs = 'mc_rtc::mc_control_fsm', min_code = False, configure_conf = True, controller_constructor = False)
    with open(project_dir + '/etc/{}.in.conf'.format(controller_name), 'w') as fd:
        fd.write("""{{
  // If true, the FSM transitions are managed by an external tool
  "Managed": false,
  // If true and the FSM is self-managed, transitions should be triggered
  "StepByStep": true,
  // Change idle behaviour, if true the state is kept until transition,
  // otherwise the FSM holds the last state until transition
  "IdleKeepState": false,
  // Where to look for state libraries
  "StatesLibraries": ["@MC_STATES_DEFAULT_INSTALL_PREFIX@","@MC_STATES_INSTALL_PREFIX@"],
  // Where to look for state files
  "StatesFiles": ["@MC_STATES_DEFAULT_INSTALL_PREFIX@/data","@MC_STATES_INSTALL_PREFIX@/data"],
  // If true, state factory will be more verbose
  "VerboseStateFactory": false,
  // Additional robots to load
  "robots":
  {{
    "ground":
    {{
      "module": "env",
      "params": ["@AROBASE@MC_ENV_DESCRIPTION@AROBASE@", "ground"]
    }}
  }},
  // General constraints, always on
  "constraints":
  [
    {{
      "type": "contact"
    }},
    {{
      "type": "dynamics",
      "robotIndex": 0,
      "damper": [0.1, 0.01, 0.5]
    }}
  ],
  // Collision constraint
  "collisions":
  [
    {{
      "type": "collision",
      "r1Index": 0,
      "r2Index": 0,
      "useMinimal": true
    }}
  ],
  // Initial set of contacts
  "contacts":
  [
    {{
      "r1": "jvrc-1",
      "r2": "ground",
      "r1Surface": "LeftFoot",
      "r2Surface": "AllGround"
    }},
    {{
      "r1": "jvrc-1",
      "r2": "ground",
      "r1Surface": "RightFoot",
      "r2Surface": "AllGround"
    }}
  ],
  // Some options for a specific robot
  "jvrc-1":
  {{
    "posture":
    {{
      "stiffness": 1.0,
      "weight": 10.0
    }},
    "ff":
    {{
      "stiffness": 2.0,
      "weight": 100.0
    }}
  }},
  // Implement some additional text states
  "states":
  {{
  }},
  // Transitions map
  "transitions":
  [
    ["{controller_name}_Initial", "OK", "{controller_name}_Initial", "Strict" ]
  ],
  // Initial state
  "init": "{controller_name}_Initial"
}}""".format(controller_name = controller_name, controller_class_name = controller_class_name))
    with open(project_dir + '/src/CMakeLists.txt', 'w') as fd:
        fd.write("""set(controller_SRC
  {controller_class_name}.cpp
)

set(controller_HDR
  {controller_class_name}.h
)

add_library(${{PROJECT_NAME}} SHARED ${{controller_SRC}} ${{controller_HDR}})
target_link_libraries(${{PROJECT_NAME}} PUBLIC mc_rtc::mc_control_fsm)
install(TARGETS ${{PROJECT_NAME}} DESTINATION "${{MC_RTC_LIBDIR}}")

add_controller(${{PROJECT_NAME}}_controller lib.cpp "")
set_target_properties(${{PROJECT_NAME}}_controller PROPERTIES OUTPUT_NAME "${{PROJECT_NAME}}")
target_link_libraries(${{PROJECT_NAME}}_controller PUBLIC ${{PROJECT_NAME}})
""".format(controller_class_name = controller_class_name))
    with open(project_dir + '/src/lib.cpp', 'w') as fd:
        fd.write("""#include "{controller_class_name}.h"

CONTROLLER_CONSTRUCTOR("{controller_name}", {controller_class_name})
""".format(controller_name = controller_name, controller_class_name = controller_class_name))
    os.makedirs(project_dir + '/src/states/data')
    with open(project_dir + '/src/CMakeLists.txt', 'a') as fd:
        fd.write('\nadd_subdirectory(states)')
    with open(project_dir + '/src/states/data/states.json', 'w') as fd:
        fd.write('{\n}')
    with open(project_dir + '/src/states/CMakeLists.txt', 'w') as fd:
        fd.write("""add_fsm_state_simple({controller_name}_Initial)

add_fsm_data_directory(data)
""".format(controller_name = controller_name))
    with open(project_dir + '/src/states/{}_Initial.h'.format(controller_name), 'w') as fd:
        fd.write("""#pragma once

#include <mc_control/fsm/State.h>

struct {controller_name}_Initial : mc_control::fsm::State
{{

    void configure(const mc_rtc::Configuration & config) override;

    void start(mc_control::fsm::Controller & ctl) override;

    bool run(mc_control::fsm::Controller & ctl) override;

    void teardown(mc_control::fsm::Controller & ctl) override;
private:
}};
""".format(controller_name = controller_name))
    with open(project_dir + '/src/states/{}_Initial.cpp'.format(controller_name), 'w') as fd:
        fd.write("""#include "{controller_name}_Initial.h"

#include "../{controller_class_name}.h"

void {controller_name}_Initial::configure(const mc_rtc::Configuration & config)
{{
}}

void {controller_name}_Initial::start(mc_control::fsm::Controller & ctl_)
{{
  auto & ctl = static_cast<{controller_class_name} &>(ctl_);
}}

bool {controller_name}_Initial::run(mc_control::fsm::Controller & ctl_)
{{
  auto & ctl = static_cast<{controller_class_name} &>(ctl_);
  return true;
}}

void {controller_name}_Initial::teardown(mc_control::fsm::Controller & ctl_)
{{
  auto & ctl = static_cast<{controller_class_name} &>(ctl_);
}}

EXPORT_SINGLE_STATE("{controller_name}_Initial", {controller_name}_Initial)
""".format(controller_name = controller_name, controller_class_name = controller_class_name))
    repo.index.add([(project_dir + f).format(controller_name) for f in ['/etc/{}.conf', '/src/CMakeLists.txt', '/src/states/data/states.json', '/src/states/CMakeLists.txt', '/src/states/{}_Initial.h', '/src/states/{}_Initial.cpp']])
    return repo

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Create a new mc_rtc FSM project')
    parser.add_argument('project_dir', metavar='[project directory]', type=str, help='Path of the project')
    parser.add_argument('controller_class_name', metavar='[controller class name]', type=str, help='Name of the controller class')
    parser.add_argument('controller_name', metavar='[controller name]', nargs='?', type=str, help='Name of the controller, defaults to controller class name', default=None)
    args = parser.parse_args()
    repo = new_fsm_controller(args.project_dir, args.controller_class_name, args.controller_name)
    repo.index.commit("Initial commit")
